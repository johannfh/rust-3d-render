use serde::{
    Deserialize, Deserializer, Serialize, Serializer,
    de::{self, Visitor},
};
use std::num::ParseFloatError;
use thiserror::Error;

#[derive(Debug, PartialEq)]
pub struct ObjFile {
    vertices: Vec<Vertex>,
}

impl ObjFile {
    pub fn new() -> Self {
        Self {
            vertices: Vec::new(),
        }
    }

    pub fn parse_vertex_line(line: &str) -> Result<Vertex, ParseVertexLineError> {
        if !line.trim().starts_with("v ") {
            return Err(ParseVertexLineError::InvalidStartingSequence(
                line.to_string(),
            ));
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 4 {
            return Err(ParseVertexLineError::NotEnoughComponents(line.to_string()));
        }

        let coords: Result<Vec<f32>, _> = parts.iter().skip(1).map(|s| s.parse::<f32>()).collect();
        let coords = match coords {
            Ok(c) => c,
            Err(e) => return Err(ParseVertexLineError::FailedToParseCoordinate(e)),
        };

        let x = coords[0];
        let y = coords[1];
        let z = coords[2];
        let w = *coords.get(3).unwrap_or(&1.0);

        Ok(Vertex::new(x, y, z, w))
    }

    pub fn to_obj_string(&self) -> String {
        let mut obj_string = String::new();
        obj_string.push_str("# Generated by custom Rust OBJ serializer\n");

        for vertex in &self.vertices {
            // Format vertex line: "v X Y Z [W]"
            if vertex.w == 1.0 {
                obj_string.push_str(&format!("v {} {} {}\n", vertex.x, vertex.y, vertex.z));
            } else {
                obj_string.push_str(&format!(
                    "v {} {} {} {}\n",
                    vertex.x, vertex.y, vertex.z, vertex.w
                ));
            }
        }

        obj_string
    }

    pub fn from_obj_string(obj_content: &str) -> Result<Self, ParseObjStringError> {
        let mut obj_file = ObjFile::new();

        for (line_idx, line) in obj_content.lines().enumerate() {
            let trimmed_line = line.trim();
            if trimmed_line.is_empty() || trimmed_line.starts_with("#") {
                continue; // Skip empty lines and comments
            }

            if trimmed_line.starts_with("v ") {
                let vertex = match ObjFile::parse_vertex_line(trimmed_line) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(ParseObjStringError::CouldNotParseVertexLine(line_idx, e));
                    }
                };
                obj_file.vertices.push(vertex);
            }
        }

        Ok(obj_file)
    }
}

#[derive(Error, Debug)]
pub enum ParseObjStringError {
    #[error("could not parse vertex line at position {0}: {1}")]
    CouldNotParseVertexLine(usize, ParseVertexLineError),
}

#[derive(Error, Debug)]
pub enum ParseVertexLineError {
    #[error("line does not start with 'v '")]
    InvalidStartingSequence(String),
    #[error("line does not have at least three vertex coordinates: `{0}`")]
    NotEnoughComponents(String),
    #[error("failed to parse a coordinate")]
    FailedToParseCoordinate(ParseFloatError),
}

impl Serialize for ObjFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_obj_string())
    }
}

impl<'de> Deserialize<'de> for ObjFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct ObjFileVisitor;

        impl<'de> Visitor<'de> for ObjFileVisitor {
            type Value = ObjFile;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a string representing an OBJ file")
            }

            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                ObjFile::from_obj_string(v).map_err(E::custom)
            }

            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                // Convert bytes to string slice and then parse
                std::str::from_utf8(v)
                    .map_err(E::custom) // Handle UTF-8 conversion error
                    .and_then(|s| ObjFile::from_obj_string(s).map_err(E::custom))
            }
        }

        deserializer.deserialize_string(ObjFileVisitor)
    }
}

#[derive(Debug, PartialEq)]
pub struct Vertex {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl Vertex {
    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Self {
        Self { x, y, z, w }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_vertex_line() {
        let line = "v 0.5 1.0 -2.0";
        let vertex = ObjFile::parse_vertex_line(line).unwrap();
        assert_eq!(vertex, Vertex::new(0.5, 1.0, -2.0, 1.0));
    }

    #[test]
    fn test_parse_obj_file_from_obj_string() {
        let obj_content = r#"
            # Simple Triangle
            v 0.0 0.0 0.0 1.0
            v 1.0 0.0 0.0 1.0
            v 0.0 1.0 0.0 1.0
        "#;

        let obj_file = ObjFile::from_obj_string(obj_content).unwrap();

        let mut vertices = obj_file.vertices.iter();

        assert_eq!(vertices.next(), Some(&Vertex::new(0.0, 0.0, 0.0, 1.0)));
        assert_eq!(vertices.next(), Some(&Vertex::new(1.0, 0.0, 0.0, 1.0)));
        assert_eq!(vertices.next(), Some(&Vertex::new(0.0, 1.0, 0.0, 1.0)));
        assert_eq!(vertices.next(), None);
    }
}


